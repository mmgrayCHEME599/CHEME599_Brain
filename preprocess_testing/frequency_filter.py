# -*- coding: utf-8 -*-
"""frequency_filter

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10hBZydW61SnPzlAHlGY5KqfFRmV0aQ7x
"""

def frequency_filter(im,filt): # general function to perform filtering in the frequency domain 
  ''' Perform filtering of an image in the frequency domain with a specified filter
    Generates a frequency filtered image using fourier transform`im_fft` from 
    input image `im` using frequency filter specified by `filt`
      

    Parameters
    ----------
    im : a grayscale image
        color images should be converted using rgb2gray
    filt : a filter to use in the frequency domain
        make sure that the filter and the image have the same dimensions

    Returns
    -------
    im_fft
        an ubyte image that represents `im` filtered in the frequency domain
        using the user-specified filter `filt`
      
    Notes
    -----
      Utilizes forward and inverse fourier transform for filtering

    Examples
    --------
    #filter grayscale cameraman image
    from skimage import data
    im=data.camera() # load cameraman image

    #define a sample filter 
    x,y=np.meshgrid(xi,yi) 
    mu1, mu2, sigmaHi = im.shape[1]/2, im.shape[0]/2, 5) 
    gfilt=np.exp(-((x-mu1)**2+(y-mu2)**2)/(2*sigmaHi**2))

    im_fft=frequency_filter(im,gfilt) # filter the image using the sample filter
    plt.imshow(im_fft) # show the resulting image 

    #frequency filter color image 
    from skimage import data, color
    im=sk.data.chelsea()
    im=sk.color.rgb2gray(im) # important additonal tep
    #define a sample filter 
    x,y=np.meshgrid(xi,yi) 
    mu1, mu2, sigmaHi = im.shape[1]/2, im.shape[0]/2, 5) 
    gfilt=np.exp(-((x-mu1)**2+(y-mu2)**2)/(2*sigmaHi**2))

    im_fft=frequency_filter(im,gfilt) # filter the image using the sample filter
    plt.imshow(im_fft) # show the resulting image 
    '''
  import scipy as sp # needed for fft
  # perform fft 
  im=img_as_float(im)
  f_im=sp.fft.fft2(im)
  # center
  f_im2=sp.fft.fftshift(f_im)
  #multiply by a filter function
  f_im3=np.multiply(f_im2, filt) 
  #un-center
  f_im4=sp.fft.ifftshift(f_im3)
  # perform inverse fft
  im_fft=np.real(sp.fft.ifft2(f_im4)) 
  return im_fft