# -*- coding: utf-8 -*-
"""gaussian_filter

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10hBZydW61SnPzlAHlGY5KqfFRmV0aQ7x
"""

def gaussian_filter(im,divisor):
  ''' Perform filtering gaussian of an image in the frequency domain 
    Generates  high (imHi) and low(imLo) frequency filtered images 
      

    Parameters
    ----------
    im : a grayscale image
        color images should be converted using rgb2gray
    divisor : the ratio of image width that should be used for kernel width

    Returns
    -------
    im_Hi
        an ubyte image that represents `im` filtered in the frequency domain
        using highpass gaussian filter with kernel width `divisor`
    im_Lo
        an ubyte image that represents `im` filtered in the frequency domain
        using lowpass gaussian filter with kernel width `divisor`
    A comparison plot of the `im` filtered using both filters
      
    Notes
    -----
      Is dependent on frequency_filter function

    Examples
    --------
    #filter grayscale cameraman image
    from skimage import data
    im=data.camera() # load cameraman image
    (imHi, imLo)=gaussian_filter(im, 2)# filter the image using kernel width 1/2 image
  

    #frequency filter color image 
    from skimage import data, color
    im=sk.data.chelsea()
    im=sk.color.rgb2gray(im) # convert to grayscale
    (imHi, imLo)=gaussian_filter(im, 4)# filter the image using kernel width 1/4 image
    '''



  xi=np.linspace(0,im.shape[1]-1,im.shape[1])
  yi=np.linspace(0,im.shape[0]-1,im.shape[0])
  x,y=np.meshgrid(xi,yi) # need to make sure filter is same shape as image
  mu1, mu2, sigmaHi, sigmaLo= im.shape[1]/2, im.shape[0]/2, im.shape[1]/divisor, im.shape[1]/divisor # bigger sigma = bigger
  gfilt=np.exp(-((x-mu1)**2+(y-mu2)**2)/(2*sigmaHi**2)) # remove high frequency 
  gfilt2=1-np.exp(-((x-mu1)**2+(y-mu2)**2)/(2*sigmaLo**2)) # remove low frequency 
  
  imHi=frequency_filter(im, gfilt2) # perform highpass filtering
  imLo=frequency_filter(im, gfilt) # perform lowpass filtering

  fig, ax=plt.subplots(figsize=(10, 10) , ncols=2)
  ax[0].imshow(imHi,cmap='gray')
  ax[0].axis('off')
  ax[0].set_title('High Pass Filtered Image')
  ax[1].imshow(imLo,cmap='gray')
  ax[1].axis('off')
  ax[1].set_title('Low Pass Filtered Image')
  
  return imHi, imLo